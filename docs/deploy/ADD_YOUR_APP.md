# Add your own app to the container

This project ships a **secure code-server (VS Code in the browser)** instance behind **Caddy TLS + Basic Auth**, with runtime secrets loaded from **Azure Key Vault**.

There are two common ways to “add your own app”:

1) **Bake your app into the image** (recommended for stable deployments)
2) **Run your app as a separate container** inside the ACI container group (advanced)

Most repos will want option (1).

## You will create/own the Dockerfile

This repo’s deployment builds **your application image** from a Dockerfile.

In practice, that means you should treat [docker/Dockerfile](../../docker/Dockerfile) as **your project’s Dockerfile**:

- Edit it to install/run your app, or
- Replace it entirely with your own Dockerfile that matches your stack.

If you prefer to keep your Dockerfile somewhere else (or maintain multiple Dockerfiles), the deploy script supports:

- `python3 scripts/deploy/azure_deploy_container.py --dockerfile path/to/Dockerfile`

## Option 1: Bake your app into the image (recommended)

### 1) Put your app code in the repo

Create a folder (example):

- `app/` (your application)

Decide whether you want it:

- copied into the image at build time, or
- mounted at runtime (local dev only)

### 2) Install dependencies in the image

Edit (or replace) the Docker build in [docker/Dockerfile](../../docker/Dockerfile).

Typical changes:

- install OS packages (via `apt-get`)
- install your runtime (Node/Python/etc.)
- copy your app code into the image

Example pattern (pseudo):

- `COPY app/ /opt/app/`
- `RUN cd /opt/app && <install deps>`

### 3) Start your app with Supervisor

This image already uses Supervisor. Add a new program stanza in:

- [docker/supervisord.conf](../../docker/supervisord.conf)

Example pattern:

- add `[program:my-app]`
- set a `command=...`
- set `autostart=true` and `autorestart=true`

If your app needs environment variables, prefer to read them from the runtime `.env` (which is fetched from Key Vault at container startup).

### 4) Expose your app through Caddy

Caddy is the only public entrypoint (ports 80/443). To route traffic to your app, update:

- [docker/Caddyfile](../../docker/Caddyfile)

Typical options:

- route `/` to code-server and `/app` to your app
- route a subdomain to your app

Make sure your app listens on an internal port and is only reachable through Caddy.

### 5) Add required env keys to the schema

If your app introduces new configuration keys:

- add them to the schema in [docs/deploy/ENV_SCHEMA.md](ENV_SCHEMA.md)
- update [env.example](../../env.example) and/or [env.deploy.example](../../env.deploy.example)

Runtime values should go in `.env` (uploaded to Key Vault). Deploy-only values should go in `.env.deploy`.

### 6) Local dev loop

- `docker compose up --build`
- open `https://localhost`

## Option 2: Run your app as a separate container in the ACI group (advanced)

If you want a sidecar container (e.g., a worker, API, database proxy) alongside code-server + Caddy:

- Update the container group YAML generation to include another container.

The YAML is generated by:

- [scripts/deploy/azure_deploy_yaml_helpers.py](../../scripts/deploy/azure_deploy_yaml_helpers.py)

You’ll need to:

- add a container entry
- add internal networking/ports
- optionally add volume mounts
- update Caddy routing if you want it public

This approach is more powerful, but increases the complexity of deploy + schema management.

## Notes on secrets and security

- Runtime secrets are expected to be in `.env` and stored as a single Key Vault secret (default name `env`).
- Avoid putting deploy credentials in `.env`.
- Do not expose app ports publicly; route through Caddy.
